syntax = "proto2";

package neuro.messages;

import "common.proto";

message Hello {
  required KeyPub key_pub = 1;
  optional int32 listen_port = 2;
}

message World {
  required bool accepted = 1;
  required KeyPub key_pub = 2;
  repeated Peer peers = 3;
}

message GetPeers {
}

message Peers {
  repeated Peer peers = 1;
}

message GetRoots {
  optional Hash last_known_root = 1;
  optional int32 count = 2; // ask for count last roots 
}

message Roots {
  repeated Hash roots = 1;
}

message GetBlock {
  oneof getblock {
    Hash hash = 1;
    uint32 height = 2;
  }
  optional uint32 count = 3;
}

message Input {
  required Hash id = 1;
  required int32 output_id = 2;
  required int32 key_id = 3;
  optional int32 signature_id = 4;
  extensions 100 to 120;
}

message Output {
  required _Address address = 1;
  required _NCCAmount value = 2;
  optional bytes data = 3;
  optional int32 output_id = 4;
}

message Signature {
  required Hash signature = 1;
  required KeyPub key_pub = 2;
}

message Transaction {
  required Hash id = 1;
  repeated Input inputs = 2;
  repeated Output outputs = 3;
  repeated Signature signatures = 4;
  repeated KeyPub key_pubs = 5;
  optional _NCCAmount fees = 6;
}

message BlockHeader {
  required Hash id = 1;
  required Timestamp timestamp = 2;
  required Hash previous_block_hash = 3;
  required KeyPub author = 5;
  optional int32 height = 6;
}

message Block {
  required BlockHeader header = 1;
  repeated Transaction transactions = 20;
}

enum Branch {
  MAIN = 0;
  FORK = 1;
  DETACHED = 2;
}

// The branch path is a strange beast.
// It should tell you where a block is in the block tree.
// The block0 has this branch path: {branch_ids: [0], block_numbers: [0]}.
// This indicates that the block0 is the block number 0 of the branch 0.
// The block at height 1 gets {branch_ids: [0], block_numbers: [1]}.
// It indicates that this block is the block number 1 of the branch 0.
// As long as you don't have a fork all blocks will stay in the branch 0.
// But let's say that you then add 2 blocks at height 2
// The first one you receive will have this branch path
// {branch_ids: [0], block_numbers: [2]}.
// And the second one will have {branch_ids: [1, 0], block_numbers: [0, 1]}
// This indicates that this block is the block number 0 of the branch 1
// and that it forked from the branch 0 at block number 1.
// If another block arrives which also has height 1 it gets
// {branch_ids: [2, 0], block_numbers: [0, 1]}.
message BranchPath {
  repeated uint32 branch_ids = 1;
  repeated uint32 block_numbers = 2;
}

message TaggedBlock {
  required Block block = 1;
  required Branch branch = 2;
  optional BranchPath branch_path = 3;
  optional double score = 4;
}

message TaggedTransaction {
  required Transaction transaction = 1;
  optional Hash block_id = 2;
}

message ConnectionClosed {
}

message ConnectionReady {
  required bool from_remote = 1;
}

message BodyCount {}

message Body {
  oneof body {
    Hello hello = 1;
    World world = 2;
    GetPeers get_peers = 3;
    Peers peers = 4;
    GetRoots get_roots = 5;
    Roots roots = 6;
    Transaction transaction = 7;
    GetBlock get_block = 8;
    Block block = 9;
    ConnectionClosed connection_closed = 10;
    ConnectionReady connection_ready = 11;
    BodyCount body_count = 12;
  }
}

message Header {
  required int32 version = 1;
  required Timestamp ts = 2;
  optional Hash signature = 3;
  optional int32 id = 11;
  optional int32 request_id = 12;
  optional Peer peer = 13;
}

message _Message {
  optional Header header = 1;
  repeated Body bodies = 20;
}

message UnspentTransaction {
  required Hash transaction_id = 1;
  required _NCCAmount value = 2;
}

message Score {
  required Hash address = 1;
  optional float score_float = 2;
}

message Election {
  required int32 id = 1;
  required Hash block_id_begin = 2;
  required Hash block_id_end = 3;
  repeated Score scores = 4;
}
